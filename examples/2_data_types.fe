function main() {
  // Booleans
  const x: boolean = true;
  const x: boolean = false;

  // Numbers
  const x: uint1 = 0;
  const x: uint8 = 0;
  const x: uint16 = 0;
  const x: uint32 = 0;
  const x: uint64 = 0;
  const x: uint128 = 0;
  const x: biguint = 0;

  const x: uint = 0; // `usize` in Rust

  const x: bit = 0; // `bit` is alias for uint1
  const x: byte = 0; // `byte` is alias for uint8

  const x: int8 = 0;
  const x: int16 = 0;
  const x: int32 = 0;
  const x: int64 = 0;
  const x: int128 = 0;
  const x: bigint = 0;

  const x: int = 0; // `isize` in Rust

  const x = 0; // numbers type-inference to int

  const x: float32 = 0;
  const x: float64 = 0;

  // Characters
  const x: char = 'a';

  // Strings
  const x: string = "Adam";
  const x: string = "Adam {x}";

  // Tuples
  const x: (uint; 3) = (1, 2, 3);
  const x: (int, string, char) = (42, "Adam", 'F');
  const x: (uint?; 10) = (none; 10);

  const y: int = x.0;
  const y: string = x.1;
  const y: char = x.2;

  // Lists
  const x: list<int> = [1, 2, 3];
  const x: list<int> = [i + 1 for i in 0..3];

  // Optionals
  const x: int? = none;
  const x: int? = some(123);
  const x: int? = 123; // automagically wrapped in `some()`

  const x: boolean = none.is_some();
  const x: boolean = none.is_none();

  const x: int = some(123).get_or_panic();
  const x: int = none.get_or(0);
  const x: int = none.get_or_else(() => 0);

  const x: int = none ?? 0;
  const x: int = none ?? () => 0;

  const x: string? = "abc";
  const y: uint? = x?.length;
  const y: uint = x?.length ?? 0;

  const x: result<int> = none.ok_or(error("uh oh!"));
  const x: result<int, string> = none.ok_or("uh oh!");
  const x: result<int, string> = none.ok_or_else(() => "uh oh!");
  const x = none.ok_or_else(() => "uh oh!");

  const x: result<int> = none ?? error;

  // Results
  const x: result<std::void, std::Error> = ok();
  const x: result<_, std::Error> = ok(); // `_` here just means use the default for that position, in this case `std::void`
  const x: result = ok;
  const x: result = error;

  const x: result<int, string> = error("uh oh!");
  const x: result<int, string> = ok(123);
  const x: result<int, string> = 123; // automagically wrapped in `ok()`

  const x: boolean = ok(123).is_ok();
  const x: boolean = ok(123).is_error();

  const x: int? = ok(123).get_ok();
  const x: std::Error? = ok(123).get_error();

  (): std::Error => {
    const x: result<int> = 123;
    const x: int = x?;
  }
}
