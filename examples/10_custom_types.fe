import { Console, Map } from "std";

immutable structure PersonId {
  state {
    public const value: string,
  }
}

structure Person {
  state {
    public const id: shared PersonId,
    let first_name: string,
    let last_name: string,
    let age: uint,
  }
}

structure PersonRepositoryError {};

contract PersonRepository {
  public mutable &self.create_person(person: shared Person): result<_, PersonRepositoryError>;
  
  public &self.find_all_people(): result<list<shared Person>, PersonRepositoryError>;
  
  public &self.find_person_by_id(id: shared PersonId): result<optional<shared Person>, PersonRepositoryError>;
  
  public mutable &self.update_person_by_id(id: shared PersonId, person: shared Person): result<_, PersonRepositoryError>;
  
  public mutable &self.delete_person_by_id(id: shared PersonId): result<_, PersonRepositoryError>;
}

structure LocalPersonRepository {
  // `(init)` allows private fields to be initialized like public fields
  state(init) {
    // `const` prevents re-assignment after construction
    // `mutable` allows Map to be mutated as long as `Self` is mutable
    // `= Map::new()` is a default value if no initial value given
    const map: mutable Map<shared PersonId, shared Person> = Map::new(),
  }

  implements PersonRepository {
    public mutable &self.create_person(person: shared Person): result<_, PersonRepositoryError> {
      self.map.put(share person.id, person);
      return ok;
    }

    public &self.find_all_people(): result<list<shared Person>, PersonRepositoryError> {
      return ok(
        self.map.values().shared()
      );
    }

    public &self.find_person_by_id(id: shared PersonId): result<optional<shared Person>, PersonRepositoryError> {
      return ok(self.map.get(&id).shared());
    }

    public mutable &self.update_person_by_id(id: shared PersonId, person: shared Person): result<_, PersonRepositoryError> {
      self.map
        .put_existing(id, person)
        .ok_or(PersonRepositoryError {})?;

      return ok;
    }

    public mutable &self.delete_person_by_id(id: shared PersonId): result<_, PersonRepositoryError> {
      return self.map
        .remove(id)
        .ok_or(PersonRepositoryError {});
    }
  }
}

// error PersonServiceError { ... }

structure PersonServiceError {}

enum FindOrAdd<T> {
  Found(T),
  Added(T),
}

contract PersonService {
  public mutable &self.add_person(person: shared Person): result<shared Person, PersonServiceError>;

  public mutable &self.find_or_add_person(person: shared Person): result<FindOrAdd<shared Person>, PersonServiceError>;
  
  public &self.find_all_people(): result<list<shared Person>, PersonServiceError>;
  
  public &self.find_person_by_id(id: shared PersonId): result<optional<shared Person>, PersonServiceError>;
  
  public mutable &self.update_person_by_id(id: shared PersonId, person: shared Person): result<shared Person, PersonServiceError>;
  
  public mutable &self.delete_person_by_id(id: shared PersonId): result<_, PersonServiceError>;
}

structure StoredPersonService {
  state(init) {
    const person_repository: mutable ~PersonRepository,
  }

  &self.get_person_by_id(id: shared PersonId): result<shared Person, PersonServiceError> {
    return self.person_repository
      .find_person_by_id(id)
      .map_err((e) => PersonServiceError {})?
      .ok_or_else(() => PersonServiceError {});
  }

  implements PersonService {
    public mutable &self.add_person(person: shared Person): result<shared Person, PersonServiceError> {
      let id = share person.id;

      self.person_repository
        .create_person(person)
        .map_err((e) => PersonServiceError {})?;
      
      return self.get_person_by_id(id);
    }

    public mutable &self.find_or_add_person(person: shared Person): result<FindOrAdd<shared Person>, PersonServiceError> {
      let existing = self
        .get_person_by_id(share person.id)
        .map_err((e) => PersonServiceError {})?;

      if some(person) matches existing {
        return ok(FindOrAdd::Found(person));
      }

      return self.add_person(person)
        .map_ok((person) => FindOrAdd::Added(person))
        .map_err((e) => PersonServiceError {});
    }

    public &self.find_all_people(): result<list<shared Person>, PersonServiceError> {
      return self.person_repository
        .find_all_people()
        .map_err((e) => PersonServiceError {});
    }

    public &self.find_person_by_id(id: shared PersonId): result<optional<shared Person>, PersonServiceError> {
      return self.person_repository
        .find_person_by_id(id)
        .map_err((e) => PersonServiceError {});
    }

    public mutable &self.update_person_by_id(id: shared PersonId, person: shared Person): result<shared Person, PersonServiceError> {
      self.person_repository
        .update_person_by_id(share id, person)
        .map_err((e) => PersonServiceError {})?;
      
      return self.get_person_by_id(id);
    }

    public mutable &self.delete_person_by_id(id: shared PersonId): result<_, PersonServiceError> {
      return self.person_repository
        .delete_person_by_id(id)
        .map_err((e) => PersonServiceError {});
    }
  }
}

structure Device {
  state {
    let instance_id: std::UUID = std::UUID::from_seed(serial),
    const serial: string,
    let is_active: bool = true,
    let is_legacy: bool = false,
  }

  // `instance_id` can be excluded from `constructor` because it has a default
  constructor { serial, is_active, is_legacy }

  // anything can be included or excluded from `get`
  get { serial, is_active, is_legacy }

  // `set` requires `let`, but `let` doesn't require `set`
  set { is_active }

  // Predefined functions to subscribe to
  subscribe {

    // `on_create` will be called just after an instance of Device is created
    // Argument is borrowed self, and can be either mutable or immutable
    // No return type is allowed
    on_create: (created: mutable &Device) => {
      Console::write_line("Created device {created.instance_id}");
    },

    // `on_drop` will be called just before an instance of Device is dropped
    // Argument is borrowed self, and can be either mutable or immutable
    // No return type is allowed
    on_drop: (dropped: mutable &Device) => {
      Console::write_line("Dropping device {dropped.instance_id}");
    },

    // `on_clone` will be called just after the instance is cloned using the `clone` keyword
    // Arguments are immutable borrowed source, and mutable borrowed clone
    // No return type is allowed
    on_clone: (source: &Device, cloned: mutable &Device) => {
      cloned.instance_id = std::UUID::from_seed(cloned.instance_id.to_string());
      Console::write_line("Cloned device {source.instance_id} into device {cloned.instance_id}");
    }

    // `on_share` will be called just after the instance is shared using the `share` keyword
    // Argument is std::Instance enum of shared self
    // No return type is allowed
    on_share: (instance: Instance<Device>) => {
      match instance {
        Instance::Mutable(mutable this) => Console::write_line("Mutably shared device {this.instance_id}"),
        Instance::Immutable(this) => Console::write_line("Immutably shared device {this.instance_id}"),
      }
    }
  }
}

function main(): result<_, PersonServiceError> {
  const person_repository = mutable LocalPersonRepository {};
  
  const person_service: ~PersonService = mutable StoredPersonService { person_repository, };

  const person1 = mutable Person {
    id: PersonId { value: "123" },
    first_name: "Adam",
    last_name: "Bates",
    age: 24,
  };

  const person2 = mutable Person {
    id: PersonId { value: "124" },
    first_name: "Madison",
    last_name: "Colletti",
    age: 23,
  };

  const added1 = person_service.add_person(share person1)?;
  Console::write_line("Added person id {added1.id.value}");

  const found_or_added1 = person_service.find_or_add_person(share person2)?;
  match found_or_added1 {
    FindOrAdd::Found(found) => Console::write_line("Found person id {found.id.value}"),
    FindOrAdd::Added(added) => Console::write_line("Added person id {added.id.value}"),
  };

  const found_or_added2 = person_service.find_or_add_person(share person2)?;
  match found_or_added2 {
    FindOrAdd::Found(found) => Console::write_line("Found person id {found.id.value}"),
    FindOrAdd::Added(added) => Console::write_line("Added person id {added.id.value}"),
  };

  person1.age = 25;
  const updated1 = person_service.update_person_by_id(share person1.id, share person1)?;
  Console::write_line("Updated person id {updated1.id.value}");

  person_service.delete_person_by_id(share person2.id)?;
  Console::write_line("Deleted person id {person2.id.value}");

  // --- //

  const inactive_legacy_device = Device {
    serial: "1",
    is_active: false,
    is_legacy: true,
  };

  const legacy_device = Device {
    serial: "2",
    is_legacy: true,
  };

  const inactive_device = Device {
    serial: "3",
    is_active: false,
  };

  const device = Device {
    serial: "4",
  };

  let x = clone device;

  {
      let share1 = share x; // calls on_share(Mutable), because no borrows exist
      let borrow1 = &share1;

      let share2 = share x; // calls on_share(Immutable), because a borrow still exists
      let borrow2 = &share2;
  }

  {
      let share1 = x.share(); // calls on_share(Mutable), because no borrows exist
      let share2 = x.share(); // calls on_share(Mutable), because still no borrows exist
  }
}
