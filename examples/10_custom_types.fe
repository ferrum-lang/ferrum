import { Console, Map } from "std";

immutable structure PersonId {
  state {
    public const value: string,
  }
}

structure Person {
  state {
    public const id: PersonId,
    let first_name: string,
    let last_name: string,
    let age: uint,
  }
}

structure PersonRepositoryError {};

contract PersonRepository {
  public mutable self.create_person(person: Person): result<_, PersonRepositoryError>;
  
  public self.find_all_people(): result<list<Person>, PersonRepositoryError>;
  
  public self.find_person_by_id(id: PersonId): result<Person?, PersonRepositoryError>;
  
  public mutable self.update_person_by_id(id: PersonId, person: Person): result<_, PersonRepositoryError>;
  
  public mutable self.delete_person_by_id(id: PersonId): result<_, PersonRepositoryError>;
}

structure LocalPersonRepository {
  state {
    // `const` prevents re-assignment after construction
    // `mutable` allows Map to be mutated as long as `Self` is mutable
    // `= Map::new()` is a default value if no initial value given
    const map: mutable Map<PersonId, Person> = Map::new(),
  }

  // `..` includes all fields, even private ones, in the constructor
  constructor { .. }

  implements PersonRepository {
    public mutable self.create_person(person: Person): result<_, PersonRepositoryError> {
      self.map.put(&person.id, person);
      return ok;
    }

    public self.find_all_people(): result<list<Person>, PersonRepositoryError> {
      return ok(
        self.map.values()
      );
    }

    public self.find_person_by_id(id: PersonId): result<Person?>, PersonRepositoryError> {
      return ok(
        self.map.get(id)
      );
    }

    public mutable self.update_person_by_id(id: PersonId, person: Person): result<_, PersonRepositoryError> {
      self.map
        .put_existing(id, person)
        .ok_or(PersonRepositoryError {})?;

      return ok;
    }

    public mutable self.delete_person_by_id(id: PersonId): result<_, PersonRepositoryError> {
      return self.map
        .remove(id)
        .ok_or(PersonRepositoryError {});
    }
  }
}

// error PersonServiceError { ... }

structure PersonServiceError {}

enum FindOrAdd<T> {
  Found(T),
  Added(T),
}

contract PersonService {
  public mutable self.add_person(person: Person): result<Person, PersonServiceError>;

  public mutable self.find_or_add_person(person: Person): result<FindOrAdd<Person>, PersonServiceError>;
  
  public self.find_all_people(): result<list<Person>, PersonServiceError>;
  
  public self.find_person_by_id(id: PersonId): result<optional<Person>, PersonServiceError>;
  
  public mutable self.update_person_by_id(id: PersonId, person: Person): result<Person, PersonServiceError>;
  
  public mutable self.delete_person_by_id(id: PersonId): result<_, PersonServiceError>;
}

structure StoredPersonService {
  state {
    const person_repository: mutable ~PersonRepository,
  }

  constructor { person_repository, }

  &self.get_person_by_id(id: PersonId): result<Person, PersonServiceError> {
    return self.person_repository
      .find_person_by_id(id)
      .map_err((e) => PersonServiceError {})?
      .ok_or_else(() => PersonServiceError {});
  }

  implements PersonService {
    public mutable self.add_person(person: Person): result<Person, PersonServiceError> {
      let id = &person.id;

      self.person_repository
        .create_person(person)
        .map_err((e) => PersonServiceError {})?;
      
      return self.get_person_by_id(id);
    }

    public mutable self.find_or_add_person(person: Person): result<FindOrAdd<Person>, PersonServiceError> {
      let existing = self
        .get_person_by_id(share person.id)
        .map_err((e) => PersonServiceError {})?;

      if some(person) matches existing {
        return ok(FindOrAdd::Found(person));
      }

      return self.add_person(person)
        .map_ok((person) => FindOrAdd::Added(person))
        .map_err((e) => PersonServiceError {});
    }

    public self.find_all_people(): result<list<Person>, PersonServiceError> {
      return self.person_repository
        .find_all_people()
        .map_err((e) => PersonServiceError {});
    }

    public self.find_person_by_id(id: PersonId): result<Person?>, PersonServiceError> {
      return self.person_repository
        .find_person_by_id(id)
        .map_err((e) => PersonServiceError {});
    }

    public mutable self.update_person_by_id(id: PersonId, person: Person): result<Person, PersonServiceError> {
      self.person_repository
        .update_person_by_id(&id, person)
        .map_err((e) => PersonServiceError {})?;
      
      return self.get_person_by_id(id);
    }

    public mutable self.delete_person_by_id(id: PersonId): result<_, PersonServiceError> {
      return self.person_repository
        .delete_person_by_id(id)
        .map_err((e) => PersonServiceError {});
    }
  }
}

function main(): result<_, PersonServiceError> {
  const person_repository = mutable LocalPersonRepository {};
  
  const person_service: ~PersonService = mutable StoredPersonService { person_repository, };

  const person1 = mutable Person {
    id: PersonId { value: "123" },
    first_name: "Adam",
    last_name: "Bates",
    age: 24,
  };

  const person2 = Person {
    id: PersonId { value: "124" },
    first_name: "Madison",
    last_name: "Colletti",
    age: 23,
  };

  // Can't share here because sharing will prevent person1 from being mutable in the future
  const added1 = person_service.add_person(person1.clone())?;
  Console::write_line("Added person id {added1.id.value}");

  const found_or_added1 = person_service.find_or_add_person(&person2)?;
  match found_or_added1 {
    FindOrAdd::Found(found) => Console::write_line("Found person id {found.id.value}"),
    FindOrAdd::Added(added) => Console::write_line("Added person id {added.id.value}"),
  };

  const found_or_added2 = person_service.find_or_add_person(&person2)?;
  match found_or_added2 {
    FindOrAdd::Found(found) => Console::write_line("Found person id {found.id.value}"),
    FindOrAdd::Added(added) => Console::write_line("Added person id {added.id.value}"),
  };

  person1.age = 25;
  const updated1 = person_service.update_person_by_id(&person1.id, &person1)?;
  Console::write_line("Updated person id {updated1.id.value}");

  person_service.delete_person_by_id(&person2.id)?;
  Console::write_line("Deleted person id {person2.id.value}");
}
