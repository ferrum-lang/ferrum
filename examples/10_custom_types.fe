import { Map } from "std";

struct PersonId {
  value: string,
}

class Person {
  state {
    public const id: PersonId,
    let first_name: string,
    let last_name: string,
    let age: uint,
  }
}

interface PersonRepository {
  self.find_all_people() -> [Person]!
  
  self.find_person_by_id(id: PersonId) -> Person?!

  mut self.create_person(person: Person) -> !
  
  mut self.update_person_by_id(id: PersonId, person: Person) -> !
  
  mut self.delete_person_by_id(id: PersonId) -> !
}

class LocalPersonRepository {
  state {
    // `const` prevents re-assignment after construction
    // `mut` allows Map to be mutated as long as `Self` is mutable
    // `= Map::new()` is a default value if no initial value given
    const map: mut Map<PersonId, Person> = Map::new(),
  }

  // `..` includes all fields, even private ones, in the constructor
  pub construct..

  impl PersonRepository {
    self.find_all_people() -> [Person]! => self.map.values()

    self.find_person_by_id(id: PersonId) -> Person?! => self.map.get(id)

    mut self.create_person(person: Person) -> ! {
      self.map.put(person.id, person)
    }

    mut self.update_person_by_id(id: PersonId, person: Person) -> ! {
      if not self.map.put_existing(id, person) {
        return err("Person with id [{id}] not found")
      }
    }

    mut self.delete_person_by_id(id: PersonId) -> ! {
      if not self.map.remove(id) {
        return err("Person with id [{id}] not found")
      }
    }
  }
}

enum FindOrAdd<T> {
  Found(T),
  Added(T),
}

interface PersonService {
  self.find_all_people() -> [Person]!
  
  self.find_person_by_id(id: PersonId) -> Person?!

  mut self.add_person(person: Person) -> Person!

  mut self.find_or_add_person(person: Person) -> FindOrAdd<Person>!
  
  mut self.update_person_by_id(id: PersonId, person: Person) -> Person!
  
  mut self.delete_person_by_id(id: PersonId) -> !
}

class StoredPersonService {
  state {
    const person_repository: mut ~PersonRepository,
  }

  self.get_person_by_id(id: PersonId) -> Person! {
    return self.person_repository
      .find_person_by_id(id)!
      .ok_or_else(() => err("Person with id [{id}] not found"))
  }

  impl PersonService {
    self.find_all_people() -> [Person]!
      => self.person_repository.find_all_people()

    self.find_person_by_id(id: PersonId) -> Person?!
      => self.person_repository.find_person_by_id(id)

    mut self.add_person(person: Person) -> Person! {
      self.person_repository.create_person(person)!
      
      return self.get_person_by_id(person.id)
    }

    mut self.find_or_add_person(person: Person) -> FindOrAdd<Person>! {
      if some(person) matches self.get_person_by_id(person.id)! {
        return FindOrAdd::Found(person)
      }

      return self.add_person(person).map_ok(FindOrAdd::Added)
    }

    mut self.update_person_by_id(id: PersonId, person: Person) -> Person! {
      self.person_repository.update_person_by_id(id, person)!
      
      return self.get_person_by_id(id)
    }

    mut self.delete_person_by_id(id: PersonId) -> ! {
      self.person_repository.delete_person_by_id(id)!
    }
  }
}

pub fn main() -> ! {
  const person_repository = mut LocalPersonRepository;
  
  const person_service: ~PersonService = mut StoredPersonService { person_repository, };

  const person1 = mut Person {
    id: PersonId { value: "123" },
    first_name: "Adam",
    last_name: "Bates",
    age: 24,
  }

  // Compiler warning: If using named-args in a constructor, consider using object-notation
  const person2 = Person(
    id = PersonId(value: "124"),
    first_name = "Madison",
    last_name = "Colletti",
    age = 23,
  )

  const added1 = person_service.add_person(person1)!
  log.info("Added person id {added1.id.value}")

  const found_or_added1 = person_service.find_or_add_person(person2)!
  match found_or_added1 {
    Found(found) => log.info("Found person id {found.id.value}"),
    Added(added) => log.info("Added person id {added.id.value}"),
  }

  const found_or_added2 = person_service.find_or_add_person(person2)!
  match found_or_added2 {
    Found(found) => log.info("Found person id {found.id.value}"),
    Added(added) => log.info("Added person id {added.id.value}"),
  }

  person1.age = 25
  const updated1 = person_service.update_person_by_id(person1.id, person1)!
  log.info("Updated person id {updated1.id.value}")

  person_service.delete_person_by_id(person2.id)!
  log.info("Deleted person id {person2.id.value}")
}
