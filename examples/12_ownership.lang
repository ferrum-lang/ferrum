import { Console } from "std";

define Person = structure {
  state(init) {
    let name: mutable string,
    let age: mutable uint,
  }

  public function requires_borrow(&self) {}

  public function requires_borrow_mut(mutable &self) {}

  public function requires_own(unique self) -> Self {
    return self;
  }
  
  public function requires_own_mut(unique mutable self) -> Self {
    return self;
  }
}

define Child = structure {
  state(init) {
    const parents: (unique Person; 2),
  }
}

// Note: functions that don't borrow data must be unique
// It is impossible to have shared + owned raw data passed in
function consume_person(person: unique Person) {
  // NO-OP
}

function main() {
  const person1 = Person {
    name: "Adam",
    age: 25,
  }.requires_own_mut();

  let person1 = person1.requires_own();

  // move, `person1` is no longer available
  const person2 = person1;

  // RC clone
  const person3 = share person2;

  // Won't compile because `person3` not `mutable`
  // const person4 = share mutable person3;

  Console::write_line("{person3.name} is {person2.age} years old.");

  const person1 = mutable Person {
    name: "Adam",
    age: 25,
  };

  // RC refCell clone
  const person2 = share mutable person1;

  // move, `person2` is no longer available, but `person1` still is
  const person3 = person2;

  // Won't compile because `person3` not `mutable`
  // person3.age = 26;

  person1.age = 26;

  Console::write_line("{person1.name} is {person3.age} years old.");

  person1.requires_borrow();
  person1.requires_borrow_mut();

  // --- //

  const mom = unique Person { name: "Madeline", age: 52, };
  const dad = unique Person { name: "Brian", age: 56, };

  // Won't compile because `mom` is marked as `unique`
  // const other = share mom;

  // Movement is still ok
  const mom = unique mom;

  const adam = Child {
    parents: (unique mom, unique dad), // requires `unique` values here
  };

  // --- //

  let person1 = Person {
    name: "Adam",
    age: 25,
  };

  {
    const person2 = share person1;

    const opt_unique_person = person1.try_unique();

    match opt_unique_person {
      ok(unique person) => {
        Console::write_line("Got unique person1 while person2 still exists!!!");
        consume_person(person);
        person1 = Person { name: "new", age: 0, };
      },
      error(person) => {
        Console::write_line("person1 cannot be made unique yet.");
        person1 = person;
      }
    }
  }

  const opt_unique_person = person1.try_unique();

  match opt_unique_person {
    ok(unique person) => {
      Console::write_line("Got unique person1 after person2 dropped.");
      consume_person(person);
    },
    error(person) => {
      Console::write_line("person1 cannot be made unique even after person2 dropped?!");
    }
  }
}
