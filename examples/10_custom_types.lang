import { Console, Map } from "std";

define PersonId = immutable structure {
  state {
    public const value: string,
  }
};

define Person = structure {
  state(init) {
    const id: shared PersonId,
    let first_name: string,
    let last_name: string,
    let age: uint,
  }
};

define PersonRepositoryError = structure {};

define PersonRepository = contract {
  public function create_person(mutable &self, person: shared Person): result<_, PersonRepositoryError>;
  public function find_all_people(&self): result<list<shared Person>, PersonRepositoryError>;
  public function find_person_by_id(&self, id: shared PersonId): result<optional<shared Person>, PersonRepositoryError>;
  public function update_person_by_id(mutable &self, id: shared PersonId, person: shared Person): result<_, PersonRepositoryError>;
  public function delete_person_by_id(mutable &self, id: shared PersonId): result<_, PersonRepositoryError>;
}

define LocalPersonRepository = structure {
  // `(init)` allows private fields to be initialized like public fields
  state(init) {
    // `const` prevents re-assignment after construction
    // `mutable` allows Map to be mutated as long as `Self` is mutable
    // `= Map::new()` is a default value if no initial value given
    const map: mutable Map<shared PersonId, shared Person> = Map::new(),
  }

  implements PersonRepository {
    function create_person(mutable &self, person: shared Person): result<_, PersonRepositoryError> {
      self.map.put(share person.id, person);
      return ok;
    }

    function find_all_people(&self): result<list<shared Person>, PersonRepositoryError> {
      return ok(
        self.map.values().shared()
      );
    }

    function find_person_by_id(&self, id: shared PersonId): result<optional<shared Person>, PersonRepositoryError> {
      return ok(self.map.get(&id).shared());
    }

    function update_person_by_id(mutable &self, id: shared PersonId, person: shared Person): result<_, PersonRepositoryError> {
      self.map
        .put_existing(id, person)
        .ok_or(PersonRepositoryError {})?;

      return ok;
    }

    function delete_person_by_id(mutable &self, id: shared PersonId): result<_, PersonRepositoryError> {
      return self.map
        .remove(id)
        .ok_or(PersonRepositoryError {});
    }
  }
}

define PersonServiceError = structure {};

define FindOrAdd = enum {
  Found(Person),
  Added(Person),
}

define PersonService = contract {
  public function add_person(mutable &self, person: shared Person): result<shared Person, PersonServiceError>;
  public function find_or_add_person(mutable &self, person: shared Person): result<FindOrAdd<shared Person>, PersonServiceError>;
  public function find_all_people(&self): result<list<shared Person>, PersonServiceError>;
  public function find_person_by_id(&self, id: shared PersonId): result<optional<shared Person>, PersonServiceError>;
  public function update_person_by_id(mutable &self, id: shared PersonId, person: shared Person): result<shared Person, PersonServiceError>;
  public function delete_person_by_id(mutable &self, id: shared PersonId): result<_, PersonServiceError>;
};

define StoredPersonService = structure {
  state(init) {
    const person_repository: mutable ~PersonRepository,
  }

  function _get_person_by_id(&self, id: shared PersonId): result<shared Person, PersonServiceError> {
    return self.person_repository
      .find_person_by_id(id)
      .map_err((e) => PersonServiceError {})?
      .ok_or_else(() => PersonServiceError {});
  }

  implements PersonService {
    public function add_person(mutable &self, person: shared Person): result<shared Person, PersonServiceError> {
      let id = share person.id;

      self.person_repository
        .create_person(person)
        .map_err((e) => PersonServiceError {})?;
      
      return self._get_person_by_id(id);
    }

    public function find_or_add_person(mutable &self, person: shared Person): result<FindOrAdd<shared Person>, PersonServiceError> {
      let existing = self
        .get_person_by_id(share person.id)
        .map_err((e) => PersonServiceError {})?;

      if some(person) matches existing {
        return ok(FindOrAdd::Found(person));
      }

      return self.add_person(person)
        .map_ok((person) => FindOrAdd::Added(person))
        .map_err((e) => PersonServiceError {});
    }

    public function find_all_people(&self): result<list<shared Person>, PersonServiceError> {
      return self.person_repository
        .find_all_people()
        .map_err((e) => PersonServiceError {});
    }

    public function find_person_by_id(&self, id: shared PersonId): result<optional<shared Person>, PersonServiceError> {
      return self.person_repository
        .find_person_by_id(id)
        .map_err((e) => PersonServiceError {});
    }

    public function update_person_by_id(mutable &self, id: shared PersonId, person: shared Person): result<shared Person, PersonServiceError> {
      self.person_repository
        .update_person_by_id(share id, person)
        .map_err((e) => PersonServiceError {})?;
      
      return self._get_person_by_id(id);
    }

    public function delete_person_by_id(mutable &self, id: shared PersonId): result<_, PersonServiceError> {
      return self.person_repository
        .delete_person_by_id(id)
        .map_err((e) => PersonServiceError {});
    }
  }
}

function main(): result<_, PersonServiceError> {
  const person_repository = mutable LocalPersonRepository {};
  
  const person_service = mutable StoredPersonService { person_repository, };

  const person1 = mutable Person {
    id: PersonId { value: "123" },
    first_name: "Adam",
    last_name: "Bates",
    age: 24,
  };

  const person2 = mutable Person {
    id: PersonId { value: "124" },
    first_name: "Madison",
    last_name: "Colletti",
    age: 23,
  };

  const added1 = person_service.add_person(share person1)?;
  Console::write_line("Added person id {added1.id.value}");

  const found_or_added1 = person_service.find_or_add_person(share person2)?;
  match found_or_added1 {
    FindOrAdd::Found(found) => Console::write_line("Found person id {found.id.value}"),
    FindOrAdd::Added(added) => Console::write_line("Added person id {added.id.value}"),
  };

  const found_or_added2 = person_service.find_or_add_person(share person2)?;
  match found_or_added2 {
    FindOrAdd::Found(found) => Console::write_line("Found person id {found.id.value}"),
    FindOrAdd::Added(added) => Console::write_line("Added person id {added.id.value}"),
  };

  person1.age = 25;
  const updated1 = person_service.update_person_by_id(share person1.id, share person1)?;
  Console::write_line("Updated person id {updated1.id.value}");

  person_service.delete_person_by_id(share person2.id)?;
  Console::write_line("Deleted person id {person2.id.value}");
}
