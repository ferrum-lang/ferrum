import { Console, Map } from "std";

define PersonId = immutable structure {
  state {
    public const value: string,
  }
};

define Person = structure {
  state(init) {
    const id: PersonId,
    let first_name: string,
    let last_name: string,
    let age: uint,
  }
};

define People = alias list<Person>;

define PersonRepositoryError = structure {};

define PersonRepository = contract {
  public function create_person(mutable &self, person: Person): result<_, PersonRepositoryError>;
  public function find_all_people(&self): result<People, PersonRepositoryError>;
  public function find_person_by_id(&self, id: PersonId): result<optional<Person>, PersonRepositoryError>;
  public function update_person_by_id(mutable &self, id: PersonId, person: Person): result<_, PersonRepositoryError>;
  public function delete_person_by_id(mutable &self, id: PersonId): result<_, PersonRepositoryError>;
}

define LocalPersonRepository = structure {
  // `(init)` allows private fields to be initialized like public fields
  state(init) {
    // `const` prevents re-assignment after construction
    // `mutable` allows Map to be mutated as long as `Self` is mutable
    // `= Map::new()` is a default value if no initial value given
    const map: mutable Map<PersonId, Person> = Map::new(),
  }

  implements PersonRepository {
    function create_person(mutable &self, person: Person): result<_, PersonRepositoryError> {
      self.map.put(person.id.clone(), person);
      return ok;
    }

    function find_all_people(&self): result<People, PersonRepositoryError> {
      return ok(
        self.map.values() // TODO: Should this be borrow or clone?
      );
    }

    function find_person_by_id(&self, id: PersonId): result<optional<Person>, PersonRepositoryError> {
      return ok(self.map.get(id)); // TODO: Clone result or return borrowed?
    }

    function update_person_by_id(mutable &self, id: PersonId, person: Person): result<_, PersonRepositoryError> {
      return self.map
        .put_existing(id, person)
        .ok_or(error(PersonRepositoryError {}));
    }

    function delete_person_by_id(mutable &self, id: PersonId): result<_, PersonRepositoryError> {
      return self.map
        .remove(id)
        .ok_or(error(PersonRepositoryError {}));
    }
  }
}

define PersonServiceError = structure {};

define FindOrAdd = enum {
  Found(Person),
  Added(Person),
}

define PersonService = contract {
  public function add_person(mutable &self, person: Person): result<Person, PersonServiceError>;
  public function find_or_add_person(mutable &self, person: Person): result<FindOrAdd<Person>, PersonServiceError>;
  public function find_all_people(&self): result<People, PersonServiceError>;
  public function find_person_by_id(&self, id: PersonId): result<optional<Person>, PersonServiceError>;
  public function update_person_by_id(mutable &self, id: PersonId, person: Person): result<Person, PersonServiceError>;
  public function delete_person_by_id(mutable &self, id: PersonId): result<_, PersonServiceError>;
};

define StoredPersonService = structure {
  state(init) {
    const person_repository: mutable ~PersonRepository,
  }

  function _get_person_by_id(&self, id: PersonId): result<Person, PersonServiceError> {
    return self.person_repository
      .find_person_by_id(person.id)
      .flatmap_ok((opt_person) => opt_person.ok_or_else((e) => PersonServiceError {}))
      .ok_or_else((e) => PersonServiceError {});
  }

  implements PersonService {
    public function add_person(mutable &self, person: Person): result<Person, PersonServiceError> {
      let id = person.id.clone();

      self.person_repository
        .create_person(person)
        .map_err((e) => PersonServiceError {})?;
      
      return self._get_person_by_id(id);
    }

    public function find_or_add_person(mutable &self, person: Person): result<FindOrAdd<Person>, PersonServiceError> {
      let existing = self.get_person_by_id(person.id.clone()).map_err((e) => PersonServiceError {})?;

      if some(person) matches existing {
        return ok(FindOrAdd::Found(person));
      }

      return self.add_person(person)
        .map_ok((person) => FindOrAdd::Added(person))
        .map_err((e) => PersonServiceError {});
    }

    public function find_all_people(&self): result<People, PersonServiceError> {
      return self.person_repository
        .find_all_people()
        .map_err((e) => PersonServiceError {});
    }

    public function find_person_by_id(&self, id: PersonId): result<optional<Person>, PersonServiceError> {
      return self.person_repository
        .find_person_by_id(id)
        .map_err((e) => PersonServiceError {});
    }

    public function update_person_by_id(mutable &self, id: PersonId, person: Person): result<Person, PersonServiceError> {
      self.person_repository
        .update_person_by_id(id.clone(), person)
        .map_err((e) => PersonServiceError {})?;
      
      return self._get_person_by_id(id);
    }

    public function delete_person_by_id(mutable &self, id: PersonId): result<_, PersonServiceError> {
      return self.person_repository
        .delete_person_by_id(id)
        .map_err((e) => PersonServiceError {});
    }
  }
}

function main(): result<_, PersonServiceError> {
  const person_repository = mutable LocalPersonRepository {};
  
  const person_service = mutable StoredPersonService { person_repository, };

  const person1 = mutable Person {
    id: PersonId { value: "123" },
    first_name: "Adam",
    last_name: "Bates",
    age: 24,
  };

  const person2 = mutable Person {
    id: PersonId { value: "124" },
    first_name: "Madison",
    last_name: "Colletti",
    age: 23,
  };

  const added1 = person_service.add_person(person1.clone())?;
  Console::write_line("Added person id {added1.id.value}");

  const found_or_added1 = person_service.find_or_add_person(person2.clone())?;
  match found_or_added1 {
    FindOrAdd::Found(found) => Console::write_line("Found person id {found.id.value}"),
    FindOrAdd::Added(added) => Console::write_line("Added person id {added.id.value}"),
  };

  const found_or_added2 = person_service.find_or_add_person(person2.clone())?;
  match found_or_added2 {
    FindOrAdd::Found(found) => Console::write_line("Found person id {found.id.value}"),
    FindOrAdd::Added(added) => Console::write_line("Added person id {added.id.value}"),
  };

  person1.age = 25;
  const updated1 = person_service.update_person_by_id(person1.id.clone(), person1.clone())?;
  Console::write_line("Updated person id {updated1.id.value}");

  person_service.delete_person_by_id(person2.id.clone())?;
  Console::write_line("Deleted person id {person2.id.value}");
}
