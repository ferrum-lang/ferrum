use hello::{self, *}
use other::foo

use(rust) low_level::low_level_func

low_level_func("Adam", "25")

/*

let x_sum = 0
let y_sum = 0

let xx_sum = 0
let xy_sum = 0

let count = 0

for (_, source_value), idx in source_data
    const (_, target_value) = target_data[idx]

    x_sum += source_value
    y_sum += target_value

    xx_sum += source_value ** 2
    xy_sum += source_value * target_value

    count += 1
;


const m = ((count * xy_sum) - (x_sum * y_sum)) / ((count * xx_sum) - (x_sum * x_sum))

const b = (y_sum / count) - ((m * x_sum) / count)

*/


fn bar() => print("bar")

fn baz() => do
    print("baz")
    print("hehehe")
;

foo()
bar()
baz()

fn xyz() => pass

xyz()

say_hello()

hello::say_hello()

// use utils::{ self, lists }

// other::foo()

// utils::strings::longest(&"a", &"b")

// lists::split_by(["a", "bbbbb"], (x) => x.len() >= 5)

fn say_something()
    inner()

    print("say_something")

    fn inner()
        print("inner")
    ;

    inner()
;

say_something()

print("\n  Hello world!  \n")

say_something()

print("")
print(true)
print(false)

////////////////

fn hello_name(name: str)
    print(name)
;

print("")
hello_name("Adam")
hello_name("Madison")
hello_name("World!")


////////////////

// explicit type, with assignment
const x: str = "x"

// implicit type, with assignment
let y = "x"

// explicit type, without assignment
const z: str


const foo: &str
let bar: &mut str

const foo: &str = &x
let bar: &mut str = &mut y

let one: str = "lol"
let two: &mut str = &mut one
const three: &&mut str = &two
const four: &str = @three
const five: &str = &@four 

const one: str = "lol"
let two: &str = &one
let three: &mut &str = &mut two
const four: &str = @three
const five: &str = &@four 

/*
    /* Nested block comments! */
*/


fn one_line_func() => print("one_line_func")

print("")
one_line_func()

