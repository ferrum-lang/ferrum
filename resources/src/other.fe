// use utils::{self, lists::from_utils_lists}

pub fn foo() { print("foo") }

fn bar() { print("bar") }


fn from_other() {
    // from_utils_lists()
}

/*

if _self.fe file is ommitted, then all files are exported:

    - main.fe (or _entry.fe? _main.fe? _app.fe?)
    - other.fe
    - utils
        - _root.fe
        - lists.fe
        - strings.fe
        - algos
          - _root.fe
          - sorting.fe
          - search.fe

utils/_root.fe
    /* super -> main.fe
     * lists -> utils/lists.fe
     * strings -> utils/strings.fe
     * algos -> utils/algos/_root.fe
     *
     * root -> NOT AVAILABLE
     */

    pub use lists
    pub use strings

utils/lists.fe
    /* root -> utils/_root.fe
     * super -> main.fe
     * strings -> utils/strings.fe
     * algos -> utils/algos/_root.fe
     */

    pub fn split_by<T>(list: [T], predicate: ~Fn(T) -> bool) -> ([T], [T]) {
        ...
    }

utils/strings.fe
    /* root -> utils/_root.fe
     * super::root -> main.fe
     * super::other -> other.fe
     * lists -> utils/lists.fe
     * algos -> utils/algos/_root.fe
     */

    pub fn longest(a: -> &string, b: -> &string) -> &string {
        ...
    }

    pub fn shortest(a: -> &string, b: -> &string) -> &string {
        ...
    }


other.fe
    /* root -> main.fe
     * utils -> utils/_root.fe
     *
     * super -> NOT AVAILABLE
     */

    use utils::*

    pub fn foo() { print("foo") }


main.fe
    /* other -> other.fe
     * utils -> utils/_root.fe
     *
     * root -> NOT AVAILABLE
     * super -> NOT AVAILABLE
     */

    use other
    use utils::{ self, lists }

    other::foo()

    utils::strings::longest(&"a", &"b")

    lists::split_by(["a", "bbbbb"], (x) => x.len() >= 5)

/// WHAT IF

- CANT access main.fe or **/_root.fe from child nodes
- CANT `pub use super...`
- **/_root.fe gives access to parent modules, but sibling/child modules have access no matter what

main.fe
    // Can't be pub
    use other::*

    // Can't be pub
    use utils::* // <- utils/_root.fe

    // MUST be pub
    pub fn main() { ... }

other.fe
    // Can't access main.fe

    pub use utils::* // <- utils/_root.fe

utils/_root.fe
    // Can't be pub
    use super::other::*

    pub use lists::* // <- utils/lists.fe

utils/lists.fe
    // Can't access utils/_root.fe

    // Can't be pub
    use super::*


///

main.fe
    use mod1::*
    use mod2::*

mod1.fe
    pub use mod2::*

    pub fn f() { }

mod2.fe
    pub use mod1::*

    pub fn f() { }


/// TO RUST:

utils/lists.rs
    pub fn ...

utils/strings.rs
    pub fn ...

    pub fn ...

utils/mod.rs
    pub mod lists;
    pub mod strings;

other.rs
    use super::utils::*;

    pub fn foo() { println!("foo"); }

main.rs
    mod other;

    mod utils;
    use utils::{ self, lists };

    ...


*/
